/**
 * TriggerDamageEntity
 * Author: Denarii Games
 * Version: 1.0
 *
 * Add component to GameObject with Collider. Check IsTrigger is enabled.
 */

using LiteNetLibManager;
using System.Collections.Generic;
using System.Reflection;
using UnityEngine;

namespace MultiplayerARPG
{
	[RequireComponent(typeof(Collider))]
	public class TriggerDamageEntity : BaseDamageEntity
	{
		[Header("Trigger Damage Settings")]
		public DamageIncremental[] damageAmount;

		[Tooltip("After trigger has applied damage, number of seconds before applying again.")]
		public float coolDownDuration = 1f;

		[Tooltip("Must exit and re-enter trigger for damage to be reapplied.")]
		public bool damageOnce = false;

		[Tooltip("Apply damage only when moving, useful for vehicles.")]
		public bool damageOnlyWhenMoving = false;

		private LiteNetLibIdentity identity;
		public LiteNetLibIdentity Identity
		{
			get
			{
				if (identity == null)
					identity = GetComponentInParent<LiteNetLibIdentity>();
				return identity;
			}
		}

		protected BaseGameEntity parent;
		protected float applyDuration;
		protected float lastAppliedTime;
		//lastPosition used for damageOnlyWhenMoving; Entity.CurrentMoveSpeed returns invalid data
		protected Vector3 lastPosition;
		protected readonly Dictionary<uint, DamageableHitBox> receivingDamageHitBoxes = new Dictionary<uint, DamageableHitBox>();

		protected override void Awake()
		{
			if (!IsServer)
				return;

			base.Awake();
			InitPrefab();
			Identity.onGetInstance.AddListener(OnGetInstance);

			parent = GetComponentInParent<BaseGameEntity>();
			this.instigator = parent == null ? EntityInfo.Empty : parent.GetInfo();
			this.weapon = null;
			this.damageAmounts = GameDataHelpers.CombineDamages(damageAmount, new Dictionary<DamageElement, MinMaxFloat>(),  0, 1f);
			this.skill = null;
			this.skillLevel = 0;
			this.applyDuration = coolDownDuration;
			lastAppliedTime = Time.unscaledTime;
		}

		protected virtual void OnDestroy()
		{
			if (!IsServer)
				return;

			Identity.onGetInstance.RemoveListener(OnGetInstance);
		}

		protected virtual void Update()
		{
			if (!IsServer)
				return;

			if (damageOnlyWhenMoving)
			{
				if (CacheTransform.position == lastPosition)
					return;
				lastPosition = CacheTransform.position;
			}

			if (receivingDamageHitBoxes.Count == 0)
				return;

			if (Time.unscaledTime - lastAppliedTime >= applyDuration)
			{
				lastAppliedTime = Time.unscaledTime;

				foreach (DamageableHitBox hitBox in receivingDamageHitBoxes.Values)
				{
					if (hitBox == null)
						continue;

					ApplyDamageTo(hitBox);
				}

				if (damageOnce)
					receivingDamageHitBoxes.Clear();
			}
		}

		public override void ApplyDamageTo(DamageableHitBox target)
		{
			if (target == null || target.IsDead() || target.IsImmune || target.IsInSafeArea)
				return;

			target.ReceiveDamageWithoutConditionCheck(CacheTransform.position, instigator, damageAmounts, weapon, skill, skillLevel, Random.Range(0, 255));
		}


		protected virtual void OnTriggerEnter(Collider other)
		{
			TriggerEnter(other.gameObject);
		}

		protected virtual void OnTriggerEnter2D(Collider2D other)
		{
			TriggerEnter(other.gameObject);
		}

		protected virtual void TriggerEnter(GameObject other)
		{
			DamageableHitBox target = other.GetComponent<DamageableHitBox>();
			if (target == null)
				return;

			uint objectId = target.GetObjectId();
			//skip if self
			if (objectId == Identity.ObjectId)
				return;
			//skip if already added
			if (receivingDamageHitBoxes.ContainsKey(objectId))
				return;

			receivingDamageHitBoxes.Add(target.GetObjectId(), target);
		}

		protected virtual void OnTriggerExit(Collider other)
		{
			TriggerExit(other.gameObject);
		}

		protected virtual void OnTriggerExit2D(Collider2D other)
		{
			TriggerExit(other.gameObject);
		}

		protected virtual void TriggerExit(GameObject other)
		{
			IDamageableEntity target = other.GetComponent<IDamageableEntity>();
			if (target.IsNull())
				return;

			if (!receivingDamageHitBoxes.ContainsKey(target.GetObjectId()))
				return;

			receivingDamageHitBoxes.Remove(target.GetObjectId());
		}

		public override void InitPrefab()
		{
			if (this == null)
			{
				Debug.LogWarning("The Base Damage Entity is null, this should not happens");
				return;
			}
			FxCollection.InitPrefab();
			if (Identity == null)
			{
				Debug.LogWarning($"No `LiteNetLibIdentity` attached with the same game object with `TriggerDamageEntity` (prefab name: {name}), it will add new identity component with asset ID which generated by prefab name.");
				LiteNetLibIdentity identity = gameObject.AddComponent<LiteNetLibIdentity>();
				FieldInfo prop = typeof(LiteNetLibIdentity).GetField("assetId", BindingFlags.NonPublic | BindingFlags.Instance);
				prop.SetValue(identity, $"TriggerDamageEntity_{name}");
			}
			Identity.PoolingSize = PoolSize;
		}
	}
}